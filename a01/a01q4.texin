First assume that the result will fit in a CPU word, so that each multiplication costs $\Theta(1)$.
\begin{algorithm}
power(base, exp)
	if exp = 1 then // base case
		return base

	let base2 = base * base
	let newexp = exp / 2 // can achieve O(1) with bit-shifting; value is truncated

	if exp is odd then // can achieve O(1) with bit-masking
		return base * power(base2, newexp)
	else
		return power(base2, newexp)
\end{algorithm}
To view the algorithm, think of the it as the bottom-up construction of a path from a specialized, complete binary tree, $B$.
\begin{itemize}
\item
Each node in $B$ contains $N_i = base^{2^i}$, where $i$ is the level from the buttom (i.e. leaf level is zero; notice in the algorithm the base case is $exp = 1$).
\item
Each node have an extra variable that decides whether $exp_i$ is odd.
\end{itemize}

Notice nodes in the leaf level contains $N_0 = base$, and the product of the bottom level is $power(base, exp)$, as described in the question and cost $\Theta(n)$.

The quicker method is to construct a path by taking, say, the right-most node.
When the recursion calls ends, the stack starts to pop and the algorithm basically calculates the following.
\begin{align*}
power(base, exp) &= N_k \times \prod_{j = 1}^{k}ifOdd(k-j,N_{k-j})
\end{align*}
where $k = height(B)$, and $ifOdd(m,N_{m})$ checks whether the $m$-th resursion step is an odd case -- if so return $N_m$; otherwise return 1.

{\bf Notice the algorithm only builds one path of $B$ from buttom-up, not the entire tree.}
Also, the running time depends on $exp$, which is being halved for each recursion call -- this is the division process.
The conquering process is when the recursion returns and fix the odd cases.

Thus,
\begin{align*}
T(n) \in \Theta(height(B)) = \Theta(\log n)
\end{align*}
\done
