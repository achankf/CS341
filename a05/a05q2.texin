{\bf Idea}
The observation is almost the same as question 1, except that the algorithm does not break whenever it reaches the threshold -- instead, it does look-ahead up to the next $80-72 = 8$ words (assuming each word has at least one character) for a word that ends with a $r$.

For example, given the string ``aaa bbb cccc rrr rrr
aaa rrr abc abc rrr
abc".
Suppose the formatting rule is 16:20, so we need 5 look-ahead words.
The algorithm would create a table of $(X, Y)$, where $X$ is the number of characters in a line (space included), and $Y$ is the number of lines that end with a $r$.

\begin{tabular}{|c|c|c|c|c|c|}
\hline
line \textbackslash look-ahead & 0 & 1 & 2 & 3 & 4 \\
\hline
1 & (16,1) & (20,1) & (20,1) & (20,1) & (20,1) \\
2 & (19,1) & (19,2) & (19,2) & (19,2) & (19,2) \\
3 & (7, 1) & (3,2)  & (3,2) & (3,2) & (3,2) \\
\hline
\end{tabular}

So we take the 20-19-3 decomposition, which looks like the following.
\begin{verbatim}
aaa bbb cccc rrr rrr
aaa rrr abc abc rrr
abc
\end{verbatim}
which is optimal because there are 2 lines that end with $r$.
Notice without the extra look-ahead words, the result would look like
\begin{verbatim}
aaa bbb cccc rrr
rrr aaa rrr abc abc
rrr abc
\end{verbatim}
which is not optimal because only one line ends with $r$.
However, it is optimal for Q1.

Now the pseudocodes.
\begin{algorithm}
function populateMaxLine(text, L=72, H=80, ending='\0', ahead=0)
	// suppose length(text) = n, split text into an array Theta(n)
	let tokens be array of text tokenize by space character
	let count be array of zeroes of size n // num char of lines
	let num_ending be 0 // count how many line ends with "ending"
	let line be 0 // iterator

	for i from 0 to size(tokens) do // Theta(n)
		set cur_len be count[line] + length(tokens[i])

		if cur_len < L then // don't need to split
			set count[line] to cur_len
			continue // avoid incrementing the line number
		else if cur_len <= H then // 72 to 80 characters reached

			// keep looking for the last word that ends with the ending character; also, in the context that this helper is used, ahead is always bounded by a constant; O(1)
			let prev_ideal = i
			let prev_len be array of zeroes of size ahead // O(1) because ahead is constantly bounded by 8

			for j from i to min(size(tokens), i + ahead) do
				set prev_len[j-i] = cur_len + length(token[j])
				if prev_len[j-i] <= H and last char of token[j] is ending then
					set prev_ideal to j
				end if
			end for
			set count[line] to prev_len[prev_ideal]
			set i = prev_ideal

		else // word too long, forced to start a new line
			set count[line + 1] to length(token[i])
		end if

		set num_ending++ whenever last char of token[i] is ending
		line++
	end for

	return (tokens, count, num_ending) // elements for recovery
\end{algorithm}

\begin{algorithm}
function findMaxLineR(text) // assuming length(text) = n
	let count2D[8][n] be 2D array of zeroes
	let num_endings[n] be array of zeroes

	for i from 0 to 8 do // populate 2D table in Theta(n) time
		let (tokens, count, n_end)
			be populateMaxLine(text, 72, 80, 'r', i) // Theta(n)
		set count2D[i] to count
		set num_endings[i] to n_end
	end for

	find i such that num_endings[i] is maximum // Theta(n)
	return recover(tokens, count2D[i]) // Theta(n)
\end{algorithm}
Notice that $i \le 8$ is constantly bounded, so {\tt populateMaxLine} runs in linear time.
Consequently, the for loop is also constantly bounded, hence the running time for {\tt findMaxLineR} is $\Theta(n)$.
\done
